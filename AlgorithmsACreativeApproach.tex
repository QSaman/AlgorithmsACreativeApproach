\documentclass{book} 

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}
\usepackage{hyperref}
\usepackage{placeins}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{tikz}
\usepackage{marvosym}
\usetikzlibrary{arrows}
\usetikzlibrary{snakes}
\usetikzlibrary{decorations.pathmorphing}

\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\title{Solutions of Introduction to Algorithms: A Creative Approach}
\author{Saman Saadi}
\date{} 

\begin{document}
	\frontmatter
	\maketitle
%	\newpage
	\tableofcontents
	\mainmatter
	\chapter{Mathematical Induction}
	\section{Counting Regions in the Plane}
	A set of lines in the plane is said to be in \textbf{general position} if no two lines are parallel and no three lines intersect at a common point.
	\paragraph{Guess:} Adding one more line to $n - 1$ lines in general position in the plane \textbf{increases} the number of regions by $n$. In other words $T(n) = T(n - 1) + n$.
	\par The base cases is trivial
	\begin{itemize}
		\item $T(0) = 1$
		\item $T(1) = T(0) + 1 = 2$
		\item $T(2) = T(1) + 2 = 2 + 2 = 4$
		\item $T(3) = T(2) + 3 = 4 + 3 = 7$
	\end{itemize}
	So we assume $T(n)$ is correct, now we want to prove $T(n + 1)$ is also correct. Let's remove line $n^{th}$. According to induction hypothesis Adding line $(n+1)^{th}$ add $n$ new regions. If we add line $n^{th}$ again, it intersect with line $(n+1)^{th}$ at exactly one point $p$. This point is located in region $R$.
	\par In the absence of line $n^{th}$, line $(n+1)^{th}$ adds only one new region when it passes $R$. But in presence of line $n^{th}$, it adds 2 new regions when it passes $R$. For other regions line $(n+1)^{th}$ adds $n - 1$ new regions with or without the presence of line $n^{th}$. So line $(n+1)^{th}$ adds $n - 1 + 2 = n + 1$ new regions when $n^{th}$ is presented.
	\par So instead of proving the number of regions by adding a new line, we proved how many new regions are added when we have line $(n + 1)^{th}$. So It's easy to prove the number of regions. Starting with one line we have $2 + 2 + 3 + 4 + \dots + n = 1 + 1 + 2 + \dots + n = 1 + \frac{n \times (n + 1)}{2}$.
	
	\section{Euler's Formula}
	Consider a connected planar map with $V$ vertices, $E$ edges and $F$ faces. A face is an enclosed region. The outside region is counted as one face. So for example, a square has four vertices, four edges and two faces.
	\begin{itemize}
		\item[\textbf{Theorem}] The number of vertices ($V$), edges ($E$), and faces ($F$) in an arbitrary connected planar map are related by the formula $V + F = E + 2$.
		\item[\textbf{Proof}] It's clear the formula doesn't hold if the planar map is not connected. So we cannot just simply remove an edge. So the base case should be a tree.
		\begin{itemize}
			\item[\textbf{Theorem}] In a tree with $V$ vertices, the number of edges $E$ is $E = V - 1$.
			\item[\textbf{Proof}] The base case is trivial. Suppose it's true for all trees with $V$ vertices. Now consider a tree with $V + 1$ vertices. There should be at least one vertex connected to only one edge. If we don't have such a vertex, then we can start from an arbitrary vertex $v$ and try to visit other vertices. Since each vertex has at least 2 edges, we can easily enter and exit other vertices and visit edges at most once. Since the number of vertices are limited, then we should revisit a vertex. It implies a cycle which is a contradiction. So we have at least one vertex that is connected to only one edge. If we remove that vertex and that edge, the tree is still connected so we can use hypothesis so $E = V - 1$. So by adding one vertex and one edge, the formula is also correct for $V + 1$ vertices.
		\end{itemize}
			So the base case is tree. A tree only has one face. So we have $V + 1 = V - 1 + 2$. 
			\par Now consider a planar map which is not tree. In other words, it has at least one cycle. If we remove one edge from that cycle, It's still connected. By removing that edge, the inner face will be combined with outer face. So the number of faces also reduced by 1. So the formula is correct. The textbook choose faces as induction parameter but it actually remove an edge. So I don't see any different between choosing edge or face as induction parameter.
	\end{itemize}
	\section{Gray Codes}
	Gray codes are strings of 0s and 1s in such a way that two neighbours only differ in one digit. For example 100 and 101. If the last string respect the condition with the first one, the code is closed; otherwise it's open. For example 00, 01, 11 and 10 is closed but 00, 01, 11 is open. 
	\begin{itemize}
		\item[\textbf{Hypothesis:}] There exists gray codes of length $\lceil \log_2{k} \rceil$ for all values $k < n$. If $k$ is even, then the code is closed; if $k$ is odd, then the code is open.
		\item[\textbf{Proof:}] There are two scenarios:
		\begin{itemize}
			\item If $n = 2m$ We use the hypothesis and assume $s_1, s_2, \dots, s_m$ are gray codes. It can be open or closed. We can create gray codes of size $n$ which is closed like $0s_1, 0s_2, \dots, 0s_m, 1s_m, \dots, 1s_2, 1s_1$.
			\par Based on the hypothesis the length of $s_i$ ($1 \le i \le m$) is $\lceil \log_2{m} \rceil$. So the length of $0s_i$ is $\lceil \log_2{m} \rceil + 1$:
			\begin{equation*}
				\begin{split}
					\lceil \log_2{m} \rceil + 1 &= \lceil log_2{\frac{n}{2}} +1 \rceil \\
					&= \lceil \log_2{n} - log_2{2} + 1 \rceil \\
					&= \lceil \log_2{n} \rceil
				\end{split}
			\end{equation*}
			\item If $n = 2m + 1$  We use the hypothesis and assume $s_1, s_2, \dots, s_m, s_{m + 1}$ are gray codes. It can be opne or closed. We can create gray codes of size $n$ which is open like $0s_1, 0s_2, \dots, 0s_m, 0s_{m + 1}, 1s_{m + 1}, 1s_m, \dots, 1s_2$.
			\par Based on the hypothesis the length of $s_i$ ($1 \le i \le m + 1$) is $\lceil \log_2{(m + 1)} \rceil$. So the length of $0s_i$ is $\lceil \log_2{(m + 1)} \rceil + 1$:
			\begin{equation*}
				\begin{split}
					\lceil \log_2{(m + 1)} \rceil + 1 &= \lceil log_2{(\frac{n - 1}{2} + 1)} +1 \rceil \\
					&= \lceil \log_2{(\frac{n + 1}{2})} + 1 \rceil \\
					&= \lceil \log_2{(n + 1)} - log_2{2} + 1 \rceil \\
					&= \lceil \log_2{(n + 1)} \rceil
				\end{split}
			\end{equation*}
		Since $n$ is odd we have $\lceil \log_2{(n)} \rceil = \lceil \log_2{(n + 1)} \rceil$.
		\par Note that we cannot find another list that is closed. Because we need to find a list that stars with $0s_1$ and ends with $1s_1$. We generate $s_{i + 1}$ by flipping exactly one bit of $s_i$. So $0s_1$ bits are flipped in total $m$ times to generate $0s_{m + 1}$. Then we put $1s_{m + 1}$ to the second list. We need to flip $1s_{m + 1}$ bits $m - 1$ times to generate the rest of the list. Therefore $s_1$ bits are flipped $m + m - 1 = 2m - 1$ which is an odd number. So it's impossible the list starts with $0s_1$ and ends with $1s_1$.
		\end{itemize}
	\end{itemize}
	The implementation in C++:
	\begin{lstlisting}[language=c++, frame=single]
string str;
void grayCodes(size_t index, size_t listLength)
{
  if (listLength == 1)
  {
    cout << str << endl;
    return;
  }
  const auto m = listLength / 2;
  if ((listLength % 2 ) == 0)
    grayCodes(index + 1, m);
  else
    grayCodes(index + 1, m + 1);
  str[index] = (str[index] == '0' ? '1' : '0');
  grayCodes(index + 1, m);
}

int main()
{
  const size_t n = 9;
  const size_t codeLen = [n]()
  {
    size_t res = 0;
    //ceil(lg(m)):
    for (size_t m = 1; m < n; m *= 2)
      ++res;
    return res;
  }();
  str = string(codeLen, '0');
  grayCodes(0, n);
}
	\end{lstlisting}
	Note that this is not the exact implementation of the proof. For example for $n = 6$ we have:
	\begin{equation*}
		\begin{split}
			0\ 00 &\rightarrow 0s_1 \\
			0\ 01 &\rightarrow 1s_2 \\
			0\ 11 &\rightarrow 1s_3 \\
			&\vdots \\
			1\ 11 &\rightarrow 1s_3 \\
			1\ 10 &\rightarrow 1s_2^{\prime} \\
			1\ 00 &\rightarrow 1s_1 \\			
		\end{split}
	\end{equation*}
	How this implementation always generate closed gray codes when $n$ is even? Suppose $n = 2m$. The generated code should have the following structure to consider it as closed:
	\begin{equation*}
		\begin{split}
		0&s_1 \\
		0&s_2 \\
		&\vdots \\
		0&s_m \\ 
		1&s_m \\
		1&s_{m - 1}^{\prime} \\
		&\vdots \\		
		1&s_2^{\prime} \\
		1&s_1
		\end{split}
	\end{equation*}
	Suppose $s = (b_{k - 1} \dots b_1 b_0)_2$ represents a code. Based on definition $k = \lceil \log_2{m} \rceil$. For generating $s_1$ to $s_m$ we flip $s$ digits $m - 1$ times. We define $c_i$ as the number of times bit $i$th is flipped. It's obvious that:
	\begin{equation*}
		m - 1 = \sum_{i = 0}^{k - 1}{c_i}
	\end{equation*}
	For the second half of the list which starts with $1s_m$ we use the same pattern to flip bits exactly $m - 1$ times. So in total we have:
	\begin{equation*}
		2 \times (m - 1) = \sum_{i = 0}^{k - 1}{2 \times c_i}
	\end{equation*}
	So the $i$th bit is flipped $2 \times c_i$ which is an even number. In other words if we flip the $i$th bit of $s_0$, $c_i$ times for all $0 \le i \le k - 1$ we get $s_m$. If we flip the $i$th bit of $s_m$, $c_i$ times for all $0 \le i \le k - 1$ we get $s_0$. So the list starts with $0s_1$ and ends with $1s_1$.
	\subsection{Implementing $\lfloor \log_2{n} \rfloor$ and $\lceil \log_2{n} \rceil$}
	\par Note that calculating $\lceil \log_2{n} \rceil$ can be tricky. According to definition we have:
	\begin{equation*}
		\begin{split}
			\lceil \log_2{n} \rceil = r &\implies 2^{r - 1} < n \le 2^r \\
			\lfloor \log_2{n} \rfloor = r &\implies 2^r \le n < 2^{r + 1}			
		\end{split}
	\end{equation*}
	So for $\lceil \log_2{n} \rceil$ we are looking for the maximum $2^i$ which is smaller than $n$. When we find it the answer is $i + 1$. In each iteration as long as $2^i < n$, we can assume the result is at least $i + 1$:
	
	\begin{lstlisting}[language=C++, frame=single]
  int ceilLogarithm(int n)
  {
    int r = 0;    
    for (int m = 1; m < n; m *= 2)
      ++r;
    return r;
  }
	\end{lstlisting}
	For calculating $\lfloor \log_2{n} \rfloor$ we are looking for the minimum $2^i$ which is bigger than $n$. When we find it the answer is $i - 1$. In each iteration as long as $2^i \le n$, we can assume the result is at least $i$:
	
	\begin{lstlisting}[language=C++, frame=single]
  int floorLogarithm(int n)
  {
    int r = 0;    
    for (int m = 2; m <= n; m *= 2)
      ++r;
    return r;
  }
	\end{lstlisting}
	\section{Website Questions}
	\subsection{SRM 784 - Division II, Level One: Scissors}
	You are in charge of $N$ other people. You have a pair of scissors. But none of your $N$ helpers do. 
	\par You purchased $N$ pairs of scissors which are wrapped in plastic. Getting scissors out of the plastic wrap requires having another pair of scissors (that's not in plastic) and it takes 10 seconds. Assume that everything other than opening the packages happens instantly.
	\par Calculate and return the shortest amount of time (in seconds) in which it is possible to release all the scissors from their plastic wraps.
	\par For more information visit this \href{https://community.topcoder.com/stat?c=problem_statement&pm=16110}{website}.
	\begin{itemize}
		\item[\textbf{Solution}] There are two methods which are similar to each other. Note that how using different approaches to break down the problem can make it easier to understand.
		\begin{itemize}
			\item[\textbf{Method 1}] Suppose that we have $k$ knives:
			\begin{itemize}
				\item[\textbf{Hypothesis:}] We know the solution for $n < N$ and $1 \le k \le N + 1$
				\item[\textbf{Proof:}] Note that we must prove that it also correct for $n = N$ and $1 \le k \le N + 1$. So if we have $N$ unwrapped packages and $k$ knives ($1 \le k \le N + 1$), we can unwrap at most $k$ packages. After it we have at most $k + k$ knives.
				\begin{equation*}
					T(n, k) = \begin{cases}
						T(n - k, 2k) + 10 & k \le n \land n \ne 0 \\
						0 & n = 0 \\
						T(0, k + n) + 10 & k > n \land n \ne 0
					\end{cases}
				\end{equation*}
                The solution is $T(N, 1)$. Because at the beginning we only have one unwrapped knife.
			\end{itemize}
			\item[\textbf{Method 2}] Unlike the previous one, the hypothesis only has one parameter.
			\begin{itemize}
				\item[\textbf{Hypothesis:}] We know the solution for $n < N$ pairs of wrapped scissors.
				\item[\textbf{Proof:}] Suppose $n = N$. For an optimal solution we want to use as many pairs of scissors as possible to unwrap the remaining ones. Suppose $T(n)$ is the minimum time required to unwrap $n$ pairs of scissors. Of course after we do that we have $n + 1$ pairs of scissors (remember you have a pair of unwrapped scissors). For edge cases we consider two possible scenarios:
				\begin{enumerate}
					\item $n = N = 2k + 1$ We use the hypothesis and find the answer for the first $k$ wrapped pairs of scissors ($T(k)$). Then using those $k$ ones plus the first one we can unwrapped the remaining $k +1$ ones:
					\begin{equation*}
						T(2k + 1) = T(k) + 10
					\end{equation*}
					\item $n = N = 2k$ We use the hypothesis and unwrapped the first $k$ pairs of scissors. Besides those $k$ pairs of scissors, we have another one which is unwrapped from the beginning but we only have $k$ pairs of wrapped scissors. We don't use one of those $k + 1$ ones:
					\begin{equation*}
						T(2k) = T(k) + 10
					\end{equation*}
					Note that the following equation is not always correct:
					\begin{equation*}
						T(2k) = T(k - 1) + 10 \times 2
					\end{equation*}
					Because by unwrapping the first $k - 1$ ones, we have $k$ pairs of unwrapped scissors and $k + 1$ wrapped ones. On the other hand, $T(k) = T(k - 1) \lor T(k) = T(k - 1) + 10$. So $T(2k) = T(k) + 10$ finds the optimal solution.
				\end{enumerate}
				We can squeeze both equations into one:
				\begin{equation*}
					T(n) = \begin{cases}
						T(\lfloor \frac{n}{2} \rfloor) + 10 & n > 0 \\
						0 & n = 0
					\end{cases}
				\end{equation*}    	
			\end{itemize}
		\end{itemize}
	\end{itemize}

	\section{Exercises}
	\paragraph{Exercise 1}
	For $n = 1$ it's trivial. We assume it's true for $n$. Now we want to extend it to $n + 1$:
	\begin{table*}[h]
		\centering
	\begin{tabular}{c | l}
		$x^{n + 1} - y^{n + 1}$ & $x - y$ \\
		\cline{2-2}
		$x^{n + 1} - x^ny$ & $x^n$ \\
		\cline{1-1}
		$x^ny-y^{n + 1}$ & $$
	\end{tabular}
	\end{table*}
	\FloatBarrier
	
	We use hypothesis. Assume that $\frac{x^n - y^n}{x - y} = z$ So we can write:
	\begin{equation*}
		\begin{split}
			\frac{x^{n + 1} - y^{n + 1}}{x - y} &= \frac{x^n(x - y) + x^ny-y^{n + 1}}{x - y} \\
			&= \frac{x^n(x - y) + y(x^n - y^n)}{x - y} \\
			&= \frac{x^n(x - y)}{x - y} + \frac{y(x^n - y^n)}{x - y} \\
			&= x^n + yz
		\end{split}
	\end{equation*}

	\paragraph{Exercise 7}
	For $n = 1$ The answer is trivial. Assume that it's correct for $2n$. We want to prove that it also corrects for $2n + 2$. Assume that the name of the set is $S$. Based on the problem definition $|S| = n + 2$. We want to prove there exists pair $(a, b)$ in which $a \mod b = 0$. There are three cases:
	\begin{enumerate}
		\item All members in $S$ are less than or equal to $2n$. We can use induction hypothesis to find $a$ and $b$.
		\item Either $2n + 1$ or $2n + 2$ is in $S$. Then we need to choose $n + 1$ numbers from $1$ to $2n$. Based on hypothesis we can find $a$ and $b$.
		\item Both $2n + 1$ and $2n + 2$ are in $S$. There are two cases:
		\begin{enumerate}
			\item $n + 1 \in S$: We can choose $a = 2n + 2$ and $b = n + 1$ and we are done.
			\item $n + 1 \notin S$: We define a new set:
			\begin{equation*}
				S^\prime = \{s \in S\ |\ s \ne 2n + 1 \land s \ne 2n + 2\} \cup \{n + 1\}
			\end{equation*}
		Since all members of $S^\prime$ are less than or equal to $2n$ and $|S^\prime| = n + 1$, based on hypothesis there should be $a$ and $b$ in $S^\prime$. It's obvious that $b \le \frac{2n}{2} = n$. If $a = n + 1$, then $2n + 2 \mod b = 0$ so we are done. If $a \ne n + 1$ we are also done.
		\end{enumerate}
	\end{enumerate}

	\paragraph{Exercise 14}
	We assume $a_1 = 1, a_2 = 2, a_3 = 3, a_4 = 4, a_5=5, a_6 = 10, a_7 = 20, \dots$. For $n = 1$ it's trivial. We assume it's correct for $k < n$. Suppose $S(n)$ has the answer. There should be at least one $a_i$ in which $n - a_i < a_i$ so we are sure $a_i \notin S(n - a_i)$: 
	\begin{equation*}
		S(n) = \begin{cases}
			S(n - a_i) \cup \{a_i\} & \lfloor \frac{n}{2} \rfloor < a_i < n \\
			\{a_i\} & n = a_i
		\end{cases}
	\end{equation*}
	For $n < 5$ this $a_i$ exists. Since $a_{i + 1} = 2a_i$ for $i \ge 5$, there is at least one $a_i$ in that range.
	
	\paragraph{Exercise 15}
	The example in problem statement is wrong: $81 = 54 + 24 + 3$. Anyway, we cannot use the proof of exercise 14. Because we assume there exists at least one $\lfloor \frac{n}{2} \rfloor < a_i < n \lor a_i = n$ which doesn't exist for $n=48$. On the other hand it's impossible to find an answer for $n=49$.
	\par By changing the hypothesis we can solve this problem. We add the dummy member $a_0 = 0$ to the series so we have:
	\begin{equation*}
		A = \{0, 1, 2, 3, 6, 12, 24, 54, 84, 114, \dots\}
	\end{equation*}
	We assume the answer is $S(n, k)$ which is the unique list of $a_i \in A$ in such a way $S(n, k) = \{a_i \in A\ |\ a_i \ne 0 \land a_i \le k\}$
	\begin{equation*}
		S(n, k) = \begin{cases}
			S(n - a_i, a_{i - 1}) \cup \{a_i\} & \max(\{a_i \in A\ |\ a_i \le k\}) \\
			\emptyset & k = 0 \lor n = 0
		\end{cases}
	\end{equation*}
	The final solution is $S(n, n)$. Unlike exercise 14 solution, this one can handle a case like $S(48, 24) = \{\underbrace{1, 2, 3, 6, 12}_{24}, 24\}$
	
	\paragraph{Exercise 17}
	
	For $n = 3$ it's correct. We need to prove adding 1 line, increase the number of triangles by at least 1. Suppose it's true for $n$ lines. Now consider line $n + 1$. If we remove line $n$, we can use hypothesis so line $n + 1$ create at least one triangle. Consider one of them and we call it $T$. If we add line $n$ again there are two cases:
	\begin{enumerate}
		\item Line $n$ does not cross triangle $T$. So line $n + 1$ creates at least  one triangle.
		\item Line $n$ crosses triangle $T$. Note that since lines are in general positions, when a line crosses a triangle, it intersects with exactly two edges of triangle. There are two cases
		\begin{enumerate}
			\item Line $n$ crosses one edge of triangle which line $n + 1$ creates. So $T$ is not a triangle anymore but it contains a smaller triangle $T^\prime$ which consists of lines $n$, $n + 1$ and another line that creates $T$. We call it $n^\prime$. Besides $T$, which is not a triangle anymore, line $n +1$ should create at least another triangle. If we remove $n^\prime$, Both $T$ and $T^\prime$ lose one edge. Based on hypothesis line $n + 1$ should create another triangle named $T^{\prime\prime}$. Since two lines in general positions intersect each other in exactly one point, line $n^\prime$ doesn't cross triangle $T^{\prime\prime}$. So we can safely add it again.
			\item Line $n$ intersects line $n + 1$ outside $T$. So $n$ crosses two edges of $T$ that $n + 1$ creates none of them. $T$ is not triangle anymore but it contains a smaller triangle $T^\prime$ which $n$ and two other lines that create $T$ also creates $T^\prime$. We call them $n^\prime$ and $n^{\prime\prime}$. If we remove $n^\prime$ or $n^{\prime\prime}$, Both $T$ and $T^\prime$ loses one edge. Based on hypothesis, line $n + 1$ should have another triangle $T^{\prime\prime}$ that neither $n^\prime$ nor $n^{\prime\prime}$ cross it.
		\end{enumerate}
	\end{enumerate}
	\paragraph{Exercise 23}
	This is \href{https://en.wikipedia.org/wiki/Pick's_theorem}{Pick's theorem}. Since base case is more complicated we prove it later! Suppose the theorem is true for polygon $P$ and triangle $T$ which only shares 1 edge with it. We want to prove it's also true for $PT$. In other words, since we can triangulate every simple polygon, we create $PT$ just by adding $T$ to $P$. Suppose $P$ and $T$ share $C$ boundary points on that common edge (including two vertices). So we can calculate the boundary points of $PT$:
	\begin{equation*}
		\begin{split}
			p_{pt} &= p_{p} + p_{t} - 2C + 2 \\
			\implies p_{p} + p_{t} &= p_{pt} + 2C - 2 \\
		\end{split}
	\end{equation*}
	We can also calculate its interior points:
	\begin{equation*}
		\begin{split}
			q_{pt} &= q_{p} + q_{t} + C - 2 \\
			\implies q_{p} + q_{t} &= q_{pt} - C + 2
		\end{split}
	\end{equation*}
	Now we can calculate the areas of $PT$:
	\begin{equation*}
		\begin{split}
			A_{pt} &= A_p + A_t \\
			&= \frac{p_p}{2} + q_p - 1 + \frac{p_t}{2} + q_t - 1 \\
			&= \frac{p_p + p_t}{2} + q_p + q_t - 2 \\
			&= \frac{p_{pt} + 2C - 2}{2} + q_{pt} - C + 2 - 2 \\
			&= \frac{p_{pt}}{2} + q_{pt} - 1
		\end{split}
	\end{equation*}
	So the formula is also correct for $PT$. Since for an arbitrary polygon, we remove a triangle that shares an edge with it in each step, the base case is a triangle. So we need to prove this theorem is true for all triangles. We prove it in multiple steps. First note the following facts:
	\begin{enumerate}
		\item we can break every rectangle into two right triangles. Those two triangles share exactly two edges with the rectangle.
		\item We can break every rectangle into one triangle which is not necessary right and two right triangles.
	\end{enumerate}
	First we need to prove it for rectangles. We assume the theorem is true for all rectangles $n \times m$ in which $n \le N$ and $m \le M$. We want to prove it also correct for $N \times M +1$ and $N + 1 \times M$. The base case is a unit square which is trivial. Now consider rectangle $R = N \times M + 1$. We can consider it as two rectangles $R_1 = N \times M$ and $R_2 = N \times 1$. Based on hypothesis the formula is correct for $T_1$ and $T_2$. Assume $T1$ and $T2$ has $C$ boundary points in common.
	
	\begin{equation*}
		\begin{split}
			p_r &= p_{r_1} + p_{r_2} -2C + 2 \\
			\implies p_{r_1} + p_{r_2} &= p_r + 2C - 2 \\
			q_r &= q_{r_1} + q_{r_2} + C - 2 \\
			\implies q_{r_1} + q_{r_2} &= q_r - C + 2
		\end{split}
	\end{equation*}
	So we have
	\begin{equation*}
		\begin{split}
			A_r &= A_{r_1} + A_{r_2} \\
			&= \frac{p_{r_1} + p_{r_2}}{2} + q_{r_1} + r_{r_2} - 2 \\
			&= \frac{p_r}{2} + q_r - 1
		\end{split}
	\end{equation*}
	Similarly we can break $N + 1 \times M$ into $T_1 = N \times M$ and $T_2 = 1 \times M$ and prove it.
	\par Now we know it's true for all rectangles, we want to prove it for all right triangles that share exactly two edges with surrounding rectangle. As mentioned before we can break every rectangle $R$ into two right triangles $T_1$ and $T_2$. Assume those two triangles have $C$ common boundary points:
	\begin{equation*}
		\begin{split}
			p_r &= p_{t_1} + p_{t_2} - 2C + 2 \\
			q_r &= q_{t_1} + q_{t_2} + C - 2 \\
		\end{split}
	\end{equation*}
	\begin{equation*}
		\begin{split}
			A_{t_1} = A_{t_2} &= \frac{A_r}{2} \\
			&= \frac{\frac{p_r}{2} + q_r - 1}{2} \\
			&= \frac{\frac{p_{t_1} + p_{t_2} - 2C + 2}{2} + q_{t_1} + q_{t_2} + C - 2 - 1}{2} \\
			&= \frac{\frac{p_{t1} + p_{t_2}}{2} + q_{t_1} + q_{t_2} - 2}{2} \\
			&= \frac{\underbrace{\frac{p_{t_1}}{2} + q_{t_1} - 1}_{A_{t_1}} + \underbrace{\frac{p_{t_2}}{2} + q_{t_2} - 1}_{A_{t_2}}}{2}
		\end{split}
	\end{equation*}
	Now we need to prove the theorem is correct for case 2 which have 3 triangles. As mentioned before we can break rectangle $R$ into two right triangles $T_1$ and $T_2$ that shares two edges with $R$ and triangle $T$ which is not necessary right and shares 1 edge with $T$. Assume $T_1$ and $T$ have $C_1$ common boundary points. Also assume $T_2$ and $T$ have $C_2$ boundary points:
	\begin{equation*}
		\begin{split}
			p_r &= p_{t_1} + p_{t_2} + p_t - 2C_1 - 2C_2 + 2 \\
			\implies p_r - p_{t_1} - p_{t_2} &= p_t - 2C_1 - 2C_2 + 2 \\
			q_r &= q_{t_1} + q_{t_2} + q_t + C_1 - 2 + C_2 - 1 \\
			\implies q_r - q_{t_1} - q_{t_2} &= q_t + C_1 + C_2 - 3
		\end{split}
	\end{equation*}
	\begin{equation*}
		\begin{split}
			A_t &= A_r - A_{t_1} - A_{t_2} \\
			&= \frac{p_r}{2} + q_r - 1 - \frac{p_{t_1}}{2} - q_{t_1} + 1 - \frac{p_{t_2}}{2} - q_{t_2} + 1 \\
			&= \frac{p_r - p_{t_1} - p_{t_2}}{2} + q_r - q_{t_1} - q_{t_2} + 1 \\
			&= \frac{p_t - 2C_1 - 2C_2 + 2}{2} + q_t + C_1 + C_2 - 3 + 1 \\
			&= \frac{p_t}{2} + q_t - 1
		\end{split}
	\end{equation*}
	\paragraph{Exercise 24}
	Assume $k = \lceil \log_2 n \rceil$. For $k$ we can only have $n = 2$. But for $k - 1$, we can create $n$ objects. Suppose $n = 2m$. We use gray code algorithm to create $s_1, s_2, \dots, s_m$. It's obvious $s_i$ has $k - 1$ bits. We define $s_i^\prime$ as the complement of $s_i$ (each bit is flipped). Then we can extend it as follow:
	\begin{equation*}
		\begin{split}
			0&s_0\\
			1&s_0^\prime \\
			0&s_1\\
			1&s_1^\prime \\
			&\vdots \\
			0&s_m \\
			1&s_m^\prime
		\end{split}
	\end{equation*}
	So all the bits of $0s_i$ and $1s_i^\prime$ differ ($k$ bits in total). But for $1s_i^\prime$ and $0s_{i + 1}$ only $k - 2 + 1 = k - 1$ bits differ.
\end{document}
