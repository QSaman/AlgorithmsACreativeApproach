\documentclass{book} 

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}
\usepackage{hyperref}
\usepackage{placeins}
\usepackage{amssymb}
\usepackage{listings}

\usepackage{tikz}
\usepackage{marvosym}
\usetikzlibrary{arrows}
\usetikzlibrary{snakes}
\usetikzlibrary{decorations.pathmorphing}

\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\title{Solutions of Introduction to Algorithms: A Creative Approach}
\author{Saman Saadi}
\date{} 

\begin{document}
	\frontmatter
	\maketitle
%	\newpage
	\tableofcontents
	\mainmatter
	\chapter{Mathematical Induction}
	\section{Counting Regions in the Plane}
	A set of lines in the plane is said to be in \textbf{general position} if no two lines are parallel and no three lines intersect at a common point.
	\paragraph{Guess:} Adding one more line to $n - 1$ lines in general position in the plane \textbf{increases} the number of regions by $n$. In other words $T(n) = T(n - 1) + n$.
	\par The base cases is trivial
	\begin{itemize}
		\item $T(0) = 1$
		\item $T(1) = T(0) + 1 = 2$
		\item $T(2) = T(1) + 2 = 2 + 2 = 4$
		\item $T(3) = T(2) + 3 = 4 + 3 = 7$
	\end{itemize}
	So we assume $T(n)$ is correct, now we want to prove $T(n + 1)$ is also correct. Let's remove line $n^{th}$. According to induction hypothesis Adding line $(n+1)^{th}$ add $n$ new regions. If we add line $n^{th}$ again, it intersect with line $(n+1)^{th}$ at exactly one point $p$. This point is located in region $R$.
	\par In the absence of line $n^{th}$, line $(n+1)^{th}$ adds only one new region when it passes $R$. But in presence of line $n^{th}$, it adds 2 new regions when it passes $R$. For other regions line $(n+1)^{th}$ adds $n - 1$ new regions with or without the presence of line $n^{th}$. So line $(n+1)^{th}$ adds $n - 1 + 2 = n + 1$ new regions when $n^{th}$ is presented.
	\par So instead of proving the number of regions by adding a new line, we proved how many new regions are added when we have line $(n + 1)^{th}$. So It's easy to prove the number of regions. Starting with one line we have $2 + 2 + 3 + 4 + \dots + n = 1 + 1 + 2 + \dots + n = 1 + \frac{n \times (n + 1)}{2}$.
	
	\section{Euler's Formula}
	Consider a connected planar map with $V$ vertices, $E$ edges and $F$ faces. A face is an enclosed region. The outside region is counted as one face. So for example, a square has four vertices, four edges and two faces.
	\begin{itemize}
		\item[\textbf{Theorem}] The number of vertices ($V$), edges ($E$), and faces ($F$) in an arbitrary connected planar map are related by the formula $V + F = E + 2$.
		\item[\textbf{Proof}] It's clear the formula doesn't hold if the planar map is not connected. So we cannot just simply remove an edge. So the base case should be a tree.
		\begin{itemize}
			\item[\textbf{Theorem}] In a tree with $V$ vertices, the number of edges $E$ is $E = V - 1$.
			\item[\textbf{Proof}] The base case is trivial. Suppose it's true for all trees with $V$ vertices. Now consider a tree with $V + 1$ vertices. There should be at least one vertex connected to only one edge. If we don't have such a vertex, then we can start from an arbitrary vertex $v$ and try to visit other vertices. Since each vertex has at least 2 edges, we can easily enter and exit other vertices and visit edges at most once. Since the number of vertices are limited, then we should revisit a vertex. It implies a cycle which is a contradiction. So we have at least one vertex that is connected to only one edge. If we remove that vertex and that edge, the tree is still connected so we can use hypothesis so $E = V - 1$. So by adding one vertex and one edge, the formula is also correct for $V + 1$ vertices.
		\end{itemize}
			So the base case is tree. A tree only has one face. So we have $V + 1 = V - 1 + 2$. 
			\par Now consider a planar map which is not tree. In other words, it has at least one cycle. If we remove one edge from that cycle, It's still connected. By removing that edge, the inner face will be combined with outer face. So the number of faces also reduced by 1. So the formula is correct. The textbook choose faces as induction parameter but it actually remove an edge. So I don't see any different between choosing edge or face as induction parameter.
	\end{itemize}
	\section{Gray Codes}
	Gray codes are strings of 0s and 1s in such a way that two neighbours only differ in one digit. For example 100 and 101. If the last string respect the condition with the first one, the code is closed; otherwise it's open. For example 00, 01, 11 and 10 is closed but 00, 01, 11 is open. 
	\begin{itemize}
		\item[\textbf{Hypothesis:}] There exists gray codes of length $\lceil \log_2{k} \rceil$ for all values $k < n$. If $k$ is even, then the code is closed; if $k$ is odd, then the code is open.
		\item[\textbf{Proof:}] There are two scenarios:
		\begin{itemize}
			\item If $n = 2m$ We use the hypothesis and assume $s_1, s_2, \dots, s_m$ are gray codes. It can be open or closed. We can create gray codes of size $n$ which is closed like $0s_1, 0s_2, \dots, 0s_m, 1s_m, \dots, 1s_2, 1s_1$.
			\par Based on the hypothesis the length of $s_i$ ($1 \le i \le m$) is $\lceil \log_2{m} \rceil$. So the length of $0s_i$ is $\lceil \log_2{m} \rceil + 1$:
			\begin{equation*}
				\begin{split}
					\lceil \log_2{m} \rceil + 1 &= \lceil log_2{\frac{n}{2}} +1 \rceil \\
					&= \lceil \log_2{n} - log_2{2} + 1 \rceil \\
					&= \lceil \log_2{n} \rceil
				\end{split}
			\end{equation*}
			\item If $n = 2m + 1$  We use the hypothesis and assume $s_1, s_2, \dots, s_m, s_{m + 1}$ are gray codes. It can be opne or closed. We can create gray codes of size $n$ which is open like $0s_1, 0s_2, \dots, 0s_m, 0s_{m + 1}, 1s_{m + 1}, 1s_m, \dots, 1s_2$.
			\par Based on the hypothesis the length of $s_i$ ($1 \le i \le m + 1$) is $\lceil \log_2{(m + 1)} \rceil$. So the length of $0s_i$ is $\lceil \log_2{(m + 1)} \rceil + 1$:
			\begin{equation*}
				\begin{split}
					\lceil \log_2{(m + 1)} \rceil + 1 &= \lceil log_2{(\frac{n - 1}{2} + 1)} +1 \rceil \\
					&= \lceil \log_2{(\frac{n + 1}{2})} + 1 \rceil \\
					&= \lceil \log_2{(n + 1)} - log_2{2} + 1 \rceil \\
					&= \lceil \log_2{(n + 1)} \rceil
				\end{split}
			\end{equation*}
		Since $n$ is odd we have $\lceil \log_2{(n)} \rceil = \lceil \log_2{(n + 1)} \rceil$.
		\par Note that we cannot find another list that is closed. Because we need to find a list that stars with $0s_1$ and ends with $1s_1$. We generate $s_{i + 1}$ by flipping exactly one bit of $s_i$. So $0s_1$ bits are flipped in total $m$ times to generate $0s_{m + 1}$. Then we put $1s_{m + 1}$ to the second list. We need to flip $1s_{m + 1}$ bits $m - 1$ times to generate the rest of the list. Therefore $s_1$ bits are flipped $m + m - 1 = 2m - 1$ which is an odd number. So it's impossible the list starts with $0s_1$ and ends with $1s_1$.
		\end{itemize}
	\end{itemize}
	The implementation in C++:
	\begin{lstlisting}[language=c++, frame=single]
string str;
void grayCodes(size_t index, size_t listLength)
{
  if (listLength == 1)
  {
    cout << str << endl;
    return;
  }
  const auto m = listLength / 2;
  if ((listLength % 2 ) == 0)
    grayCodes(index + 1, m);
  else
    grayCodes(index + 1, m + 1);
  str[index] = (str[index] == '0' ? '1' : '0');
  grayCodes(index + 1, m);
}

int main()
{
  const size_t n = 9;
  const size_t codeLen = [n]()
  {
    size_t res = 0;
    //ceil(lg(m)):
    for (size_t m = 1; m < n; m *= 2)
      ++res;
    return res;
  }();
  str = string(codeLen, '0');
  grayCodes(0, n);
}
	\end{lstlisting}
	Note that this is not the exact implementation of the proof. For example for $n = 6$ we have:
	\begin{equation*}
		\begin{split}
			0\ 00 &\rightarrow 0s_1 \\
			0\ 01 &\rightarrow 1s_2 \\
			0\ 11 &\rightarrow 1s_3 \\
			&\vdots \\
			1\ 11 &\rightarrow 1s_3 \\
			1\ 10 &\rightarrow 1s_2^{\prime} \\
			1\ 00 &\rightarrow 1s_1 \\			
		\end{split}
	\end{equation*}
	How this implementation always generate closed gray codes when $n$ is even? Suppose $n = 2m$. The generated code should have the following structure to consider it as closed:
	\begin{equation*}
		\begin{split}
		0&s_1 \\
		0&s_2 \\
		&\vdots \\
		0&s_m \\ 
		1&s_m \\
		1&s_{m - 1}^{\prime} \\
		&\vdots \\		
		1&s_2^{\prime} \\
		1&s_1
		\end{split}
	\end{equation*}
	Suppose $s = (b_{k - 1} \dots b_1 b_0)_2$ represents a code. Based on definition $k = \lceil \log_2{m} \rceil$. For generating $s_1$ to $s_m$ we flip $s$ digits $m - 1$ times. We define $c_i$ as the number of times bit $i$th is flipped. It's obvious that:
	\begin{equation*}
		m - 1 = \sum_{i = 0}^{k - 1}{c_i}
	\end{equation*}
	For the second half of the list which starts with $1s_m$ we use the same pattern to flip bits exactly $m - 1$ times. So in total we have:
	\begin{equation*}
		2 \times (m - 1) = \sum_{i = 0}^{k - 1}{2 \times c_i}
	\end{equation*}
	So the $i$th bit is flipped $2 \times c_i$ which is an even number. In other words if we flip the $i$th bit of $s_0$, $c_i$ times for all $0 \le i \le k - 1$ we get $s_m$. If we flip the $i$th bit of $s_m$, $c_i$ times for all $0 \le i \le k - 1$ we get $s_0$. So the list starts with $0s_1$ and ends with $1s_1$.
	\subsection{Implementing $\lfloor \log_2{n} \rfloor$ and $\lceil \log_2{n} \rceil$}
	\par Note that calculating $\lceil \log_2{n} \rceil$ can be tricky. According to definition we have:
	\begin{equation*}
		\begin{split}
			\lceil \log_2{n} \rceil = r &\implies 2^{r - 1} < n \le 2^r \\
			\lfloor \log_2{n} \rfloor = r &\implies 2^r \le n < 2^{r + 1}			
		\end{split}
	\end{equation*}
	So for $\lceil \log_2{n} \rceil$ we are looking for the maximum $2^i$ which is smaller than $n$. When we find it the answer is $i + 1$. In each iteration as long as $2^i < n$, we can assume the result is at least $i + 1$:
	
	\begin{lstlisting}[language=C++, frame=single]
  int ceilLogarithm(int n)
  {
    int r = 0;    
    for (int m = 1; m < n; m *= 2)
      ++r;
    return r;
  }
	\end{lstlisting}
	For calculating $\lfloor \log_2{n} \rfloor$ we are looking for the minimum $2^i$ which is bigger than $n$. When we find it the answer is $i - 1$. In each iteration as long as $2^i \le n$, we can assume the result is at least $i$:
	
	\begin{lstlisting}[language=C++, frame=single]
  int floorLogarithm(int n)
  {
    int r = 0;    
    for (int m = 2; m <= n; m *= 2)
      ++r;
    return r;
  }
	\end{lstlisting}
	\section{Website Questions}
	\subsection{SRM 784 - Division II, Level One: Scissors}
	You are in charge of $N$ other people. You have a pair of scissors. But none of your $N$ helpers do. 
	\par You purchased $N$ pairs of scissors which are wrapped in plastic. Getting scissors out of the plastic wrap requires having another pair of scissors (that's not in plastic) and it takes 10 seconds. Assume that everything other than opening the packages happens instantly.
	\par Calculate and return the shortest amount of time (in seconds) in which it is possible to release all the scissors from their plastic wraps.
	\par For more information visit this \href{https://community.topcoder.com/stat?c=problem_statement&pm=16110}{website}.
	\begin{itemize}
		\item[\textbf{Solution}] There are two methods which are similar to each other. Note that how using different approaches to break down the problem can make it easier to understand.
		\begin{itemize}
			\item[\textbf{Method 1}] Suppose that we have $k$ knives:
			\begin{itemize}
				\item[\textbf{Hypothesis:}] We know the solution for $n < N$ and $1 \le k \le N + 1$
				\item[\textbf{Proof:}] Note that we must prove that it also correct for $n = N$ and $1 \le k \le N + 1$. So if we have $N$ unwrapped packages and $k$ knives ($1 \le k \le N + 1$), we can unwrap at most $k$ packages. After it we have at most $k + k$ knives.
				\begin{equation*}
					T(n, k) = \begin{cases}
						T(n - k, 2k) + 10 & k \le n \land n \ne 0 \\
						0 & n = 0 \\
						T(0, k + n) + 10 & k > n \land n \ne 0
					\end{cases}
				\end{equation*}
                The solution is $T(N, 1)$. Because at the beginning we only have one unwrapped knife.
			\end{itemize}
			\item[\textbf{Method 2}] Intuitively we can use a binary tree. Each node has out-degree 0 (leaf) or 2 (node). For example for $N = 4$, we show the pair of scissors $1\le i \le N$ as $i$. The first pair of scissors which are unwrapped is shown as $0$:
			
			\begin{figure*}[h!]
				\centering
				\begin{tikzpicture}[level/.style={sibling distance=60mm/#1}]
					\tikzset{vertex/.style = {shape=circle,draw,scale=0.7}}
					\node[vertex] (a){$0$ \LeftScissors $1$}
					child {node[vertex] (b) {$0$ \LeftScissors $2$}
						child {node[vertex] (d) {$0$ \LeftScissors $4$}
							child {node[vertex] (h) {$0$}}
							child {node[vertex] (i) {$4$}}
						}
						child {node[vertex] (e) {$2$}}
					}
					child {node[vertex] (c) {$1$ \LeftScissors $3$}
						child {node[vertex] (f) {$1$}}
						child {node[vertex] (g) {$3$}}
					}
					;
				\end{tikzpicture}
			\end{figure*}
			\FloatBarrier
			As you can see at the beginning we only have a pair of scissors $0$. Using it we unwrap the pair of scissors $1$. In the next step we unwrap $2$ with $0$ and $3$ with $1$ simultaneously. So for $N=4$, the answer is $h \times 10 = 3 \times 10 = 30$. $h$ is the height of the tree. We can solve it using mathematical induction.
			\begin{itemize}
				\item[\textbf{Hypothesis:}] We know the solution for $n < N$ pairs of wrapped scissors.
				\item[\textbf{Proof:}] Suppose $n = N$. For an optimal solution we want to use as many pairs of scissors as possible to unwrap the remaining ones. Suppose $T(n)$ is the minimum time required to unwrap $n$ pairs of scissors. Of course after we do that we have $n + 1$ pairs of scissors (remember you have a pair of unwrapped scissors). For edge cases we consider two possible scenarios:
				\begin{enumerate}
					\item $n = N = 2k + 1$ We use the hypothesis and find the answer for the first $k$ wrapped pairs of scissors ($T(k)$). Then using those $k$ ones plus the first one we can unwrapped the remaining $k +1$ ones:
					\begin{equation*}
						T(2k + 1) = T(k) + 10
					\end{equation*}
					\item $n = N = 2k$ We use the hypothesis and unwrapped the first $k$ pairs of scissors. Besides those $k$ pairs of scissors, we have another one which is unwrapped from the beginning but we only have $k$ pairs of wrapped scissors. We don't use one of those $k + 1$ ones:
					\begin{equation*}
						T(2k) = T(k) + 10
					\end{equation*}
					Note that the following equation is not always correct:
					\begin{equation*}
						T(2k) = T(k - 1) + 10 \times 2
					\end{equation*}
					Because by unwrapping the first $k - 1$ ones, we have $k$ pairs of unwrapped scissors and $k + 1$ wrapped ones. On the other hand, $T(k) = T(k - 1) \lor T(k) = T(k - 1) + 10$. So $T(2k) = T(k) + 10$ finds the optimal solution.
				\end{enumerate}
				We can squeeze both equations into one:
				\begin{equation*}
					T(n) = \begin{cases}
						T(\lfloor \frac{n}{2} \rfloor) + 10 & n > 0 \\
						0 & n = 0
					\end{cases}
				\end{equation*}    	
			\end{itemize}
		\end{itemize}
	\end{itemize}
	
\end{document}
